import numpy as np
import torch
import torchvision
import sys
import argparse
import math

from torchvision.transforms import ToTensor
from torch.utils.data import DataLoader
import torch.optim as optim
from pathlib import Path

from train import train
from test import test
from data import generate_labelsets, IQDataset
from report import report
import models

"""
Experiments: Each experiment tests diffent data inputs with the same model.

run this file with 'poetry run python <experiments>'

create_labelsets:
    Utility which when run will create and save new randomized labels for the data.
    it's recommended that you run this once (or use the included labels) and not again between trials.

typst:
    Utility which when enabled will call typst as a subprocess to compile the autogenerated reports. 
    Requires you to have typst installed in '/opt/homebrew/bin/typst'.
    Change the path in report.py if needed. 

noise:
    Experiment which tests the effect of signal to noise ratio on classification accuracy.
    note: trains multiple models

decimation:
    Experiment which tests the effect of signal decimation on classification accuracy.
    note: trains 70 models

wired_main:
    Experiment which trains a single model with settings meant to replicate the study.
    Runs with decimation = 2, window = 400 on the wired dataset.
    note: there is a small chance that the model will get stuck on local minimum and 
        never escape the 'always choose a single class' strategy. 

wired_normalized:
    Identical to wired_main but with normalization.
    note: normalization appears to increase the chances
        of the 'always choose a single class' strategy local optima.

wired_fullwidth:
    Experiment which trains the wired dataset on all 1024 samples with no preprocessing.

windowed_random:
    Experiment which randomly offsets the 800 frame windows in each sample.
    In practice this will never escape the single-class strategy (or at least it's extremely unlikly). 

room_main:
    Replicates wired_main on the wireless dataset
    Runs with decimation = 2, window = 400, and normalization on the 'room' dataset.
    note: more variable results than wired data.

room_fullwidth: 
    Experiment which trains the wireless 'room' dataset on all 1024 samples with no preprocessing.

room_normalized:
    Identical to room_main but with normalization.    
    note: normalization appears to increase the chances
        of the 'always choose a single class' strategy local optima.
"""
experiments = {
        'create_labelsets': False,
        'typst': True,
        'noise': False,
        'decimation': False,
        'decimation_contrast': False,
        'decimation_reversed': False,
        'windowing_contrast': False,
        'wired_main': False,
        'wired_normalized': False,
        'wired_fullwidth': False,
        'windowed_random': False,
        'room_main': False,
        'room_fullwidth': False,
        'room_normalized': False
}

args = sys.argv[1:]
for arg in args:
    experiments[arg] = True
    
typst = experiments['typst']

if experiments['create_labelsets']:
    wired_tr, wired_ts = generate_labelsets('wired_250_24')
    room_tr, room_ts = generate_labelsets('room_250_16')
    np.savez('dataset/labels.npz', wired_tr=wired_tr, wired_ts=wired_ts, room_tr=room_tr, room_ts=room_ts)

if experiments['noise']:
    name = 'noise'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 50

    Path(f"results/{name}").mkdir(exist_ok=True)
    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']
    
    rpt = report(name, dataset, lr, epochs)

    tr_data = IQDataset(tr_labels, decimation=2, window=400)
    tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
    network = models.Multi_Net(input_len=400)
    opt = optim.Adam(network.parameters(), lr)
    loss = train(name, network, opt, tr_loader, epochs)

    accuracy = []
    accuracy_labels = []
    for snr in [-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]:
        ts_data = IQDataset(ts_labels, decimation=2, window=400, noise=snr)
        ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
        results = test(network, ts_loader)
        accuracy.append(results['accuracy'])
        accuracy_labels.append(f"{snr}")

    rpt.add_loss_figure(loss) 
    rpt.add_accuracy_graph(accuracy, "SNR (dB)", x_labels=accuracy_labels)
    rpt.save()
    if typst: rpt.compile()

if experiments['decimation_reversed']:
    name = 'decimation_reversed'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 20

    Path(f"results/{name}").mkdir(exist_ok=True)
    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']

    rpt = report(name, dataset, lr, epochs)
    accuracy = []
    accuracy_labels = []
    for d in [128, 64, 16, 2]:
        mloss_trial = {}
        trial_accuracy = 0;
        for i in range(50):
            tr_data = IQDataset(tr_labels, decimation=d, normalized=True)
            ts_data = IQDataset(ts_labels, decimation=d, normalized=True)
            tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
            ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
            network = models.Multi_Net(input_len=math.ceil(1024/d))
            opt = optim.Adam(network.parameters(), lr)
            loss = train(name, network, opt, tr_loader, epochs)
            results = test(network, ts_loader)
            mloss_trial[f"t = {i}"] = loss
            trial_accuracy += results['accuracy']
        accuracy.append(trial_accuracy / 50)
        accuracy_labels.append(f"{d}")
        rpt.add_multi_loss(mloss_trial, alt_name=f"decimation_{d}")

    rpt.add_accuracy_graph(accuracy, "decimation", x_labels=accuracy_labels)
    rpt.save()
    if typst: rpt.compile()

if experiments['decimation_contrast']:
    name = 'decimation_contrast'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 20

    Path(f"results/{name}").mkdir(exist_ok=True)
    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']

    rpt = report(name, dataset, lr, epochs)
    accuracy = []
    accuracy_labels = []
    for d in [2, 16, 64, 128]:
        mloss_trial = {}
        trial_accuracy = 0;
        for i in range(50):
            tr_data = IQDataset(tr_labels, decimation=d, normalized=True)
            ts_data = IQDataset(ts_labels, decimation=d, normalized=True)
            tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
            ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
            network = models.Multi_Net(input_len=math.ceil(1024/d))
            opt = optim.Adam(network.parameters(), lr)
            loss = train(name, network, opt, tr_loader, epochs)
            results = test(network, ts_loader)
            mloss_trial[f"t = {i}"] = loss
            trial_accuracy += results['accuracy']
        accuracy.append(trial_accuracy / 50)
        accuracy_labels.append(f"{d}")
        rpt.add_multi_loss(mloss_trial, alt_name=f"decimation_{d}")

    rpt.add_accuracy_graph(accuracy, "decimation", x_labels=accuracy_labels)
    rpt.save()
    if typst: rpt.compile()

if experiments['windowing_contrast']:
    name = 'windowing_contrast'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 20

    Path(f"results/{name}").mkdir(exist_ok=True)
    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']

    rpt = report(name, dataset, lr, epochs)
    accuracy = []
    accuracy_labels = []
    for d in [2, 16, 64, 128]:
        mloss_trial = {}
        trial_accuracy = 0;
        for i in range(50):
            samples = math.ceil(1024/d)
            tr_data = IQDataset(tr_labels, window=samples, normalized=True)
            ts_data = IQDataset(ts_labels, window=samples, normalized=True)
            tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
            ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
            network = models.Multi_Net(input_len=samples)
            opt = optim.Adam(network.parameters(), lr)
            loss = train(name, network, opt, tr_loader, epochs)
            results = test(network, ts_loader)
            mloss_trial[f"t = {i}"] = loss
            trial_accuracy += results['accuracy']
        accuracy.append(trial_accuracy / 50)
        accuracy_labels.append(f"{d}")
        rpt.add_multi_loss(mloss_trial, alt_name=f"window_{d}")

    rpt.add_accuracy_graph(accuracy, "windowing", x_labels=accuracy_labels)
    rpt.save()
    if typst: rpt.compile()

if experiments['decimation']:
    name = 'decimation'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 50

    Path(f"results/{name}").mkdir(exist_ok=True)
    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']

    rpt = report(name, dataset, lr, epochs)
    accuracy = []
    accuracy_labels = []
    for d in [2, 4, 8, 16, 32, 64, 128]:
        mloss_trial = {}
        trial_accuracy = 0;
        for i in range(10):
            tr_data = IQDataset(tr_labels, decimation=d, normalized=True)
            ts_data = IQDataset(ts_labels, decimation=d, normalized=True)
            tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
            ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
            network = models.Multi_Net(input_len=math.ceil(1024/d))
            opt = optim.Adam(network.parameters(), lr)
            loss = train(name, network, opt, tr_loader, epochs)
            results = test(network, ts_loader)
            mloss_trial[f"t = {i}"] = loss
            trial_accuracy += results['accuracy']
        accuracy.append(trial_accuracy / 10)
        accuracy_labels.append(f"{d}")
        rpt.add_multi_loss(mloss_trial, alt_name=f"decimation_{d}")

    rpt.add_accuracy_graph(accuracy, "decimation", x_labels=accuracy_labels)
    rpt.save()
    if typst: rpt.compile()

if experiments['wired_main']:
    name = 'wired_main'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 50

    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']
    
    tr_data = IQDataset(tr_labels, decimation=2, window=400)
    ts_data = IQDataset(ts_labels, decimation=2, window=400)

    tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
    ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
    
    network = models.Multi_Net(input_len=400)
    opt = optim.Adam(network.parameters(), lr)

    Path(f"results/{name}").mkdir(exist_ok=True)

    loss = train(name, network, opt, tr_loader, epochs)
    results = test(network, ts_loader)
    
    rpt = report(name, dataset, lr, epochs)
    rpt.add_accuracy(results['accuracy'])
    rpt.add_loss_figure(loss)
    rpt.add_confusion(results, ts_data.classes)
    rpt.save()
    if typst: rpt.compile()

if experiments['wired_normalized']:
    name = 'wired_normalized'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 50

    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']
    
    tr_data = IQDataset(tr_labels, decimation=2, normalized=True, window=400)
    ts_data = IQDataset(ts_labels, decimation=2, normalized=True, window=400)

    tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
    ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
    
    network = models.Multi_Net(input_len=400)
    opt = optim.Adam(network.parameters(), lr)

    Path(f"results/{name}").mkdir(exist_ok=True)

    loss = train(name, network, opt, tr_loader, epochs)
    results = test(network, ts_loader)
    
    rpt = report(name, dataset, lr, epochs)
    rpt.add_accuracy(results['accuracy'])
    rpt.add_loss_figure(loss)
    rpt.add_confusion(results, ts_data.classes)
    rpt.save()
    if typst: rpt.compile()

if experiments['wired_fullwidth']:
    name = 'wired_fullwidth'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 50

    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']
    
    tr_data = IQDataset(tr_labels)
    ts_data = IQDataset(ts_labels)

    tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
    ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
    
    network = models.Multi_Net()
    opt = optim.Adam(network.parameters(), lr)

    Path(f"results/{name}").mkdir(exist_ok=True)

    loss = train(name, network, opt, tr_loader, epochs)
    results = test(network, ts_loader)
    
    rpt = report(name, dataset, lr, epochs)
    rpt.add_accuracy(results['accuracy'])
    rpt.add_loss_figure(loss)
    rpt.add_confusion(results, ts_data.classes)
    rpt.save()
    if typst: rpt.compile()

if experiments['windowed_random']:
    name = 'windowed_random'
    dataset = 'wired_250_24'
    batch_size = 200
    lr = 0.001
    epochs = 50

    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['wired_tr']
    ts_labels = stored_labels['wired_ts']
    
    tr_data = IQDataset(tr_labels, window=800, window_offset='rand')
    ts_data = IQDataset(ts_labels, window=800, window_offset='rand')

    tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
    ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
    
    network = models.Multi_Net(input_len=800)
    opt = optim.Adam(network.parameters(), lr)

    Path(f"results/{name}").mkdir(exist_ok=True)

    loss = train(name, network, opt, tr_loader, epochs)
    results = test(network, ts_loader)
 
    rpt = report(name, dataset, lr, epochs)
    rpt.add_accuracy(results['accuracy'])
    rpt.add_loss_figure(loss)
    rpt.add_confusion(results, ts_data.classes)
    rpt.save()
    if typst: rpt.compile()

if experiments['room_main']:
    name = 'room_main'
    dataset = 'room_250_16'
    batch_size = 200
    lr = 0.001
    epochs = 50

    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['room_tr']
    ts_labels = stored_labels['room_ts']
    
    tr_data = IQDataset(tr_labels, decimation=2, window=400)
    ts_data = IQDataset(ts_labels, decimation=2, window=400)

    tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
    ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
    
    network = models.Multi_Net(input_len=400)
    opt = optim.Adam(network.parameters(), lr)

    Path(f"results/{name}").mkdir(exist_ok=True)

    loss = train(name, network, opt, tr_loader, epochs)
    results = test(network, ts_loader)
    
    rpt = report(name, dataset, lr, epochs)
    rpt.add_accuracy(results['accuracy'])
    rpt.add_loss_figure(loss)
    rpt.add_confusion(results, ts_data.classes)
    rpt.save()
    if typst: rpt.compile()

if experiments['room_fullwidth']:
    name = 'room_fullwidth'
    dataset = 'room_250_16'
    batch_size = 200
    lr = 0.001
    epochs = 50

    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['room_tr']
    ts_labels = stored_labels['room_ts']
    
    tr_data = IQDataset(tr_labels)
    ts_data = IQDataset(ts_labels)

    tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
    ts_loader = DataLoader(ts_data, batch_size, shuffle=True)

    network = models.Multi_Net()
    opt = optim.Adam(network.parameters(), lr)

    Path(f"results/{name}").mkdir(exist_ok=True)

    loss = train(name, network, opt, tr_loader, epochs)
    results = test(network, ts_loader)

    rpt = report(name, dataset, lr, epochs)
    rpt.add_accuracy(results['accuracy'])
    rpt.add_loss_figure(loss)
    rpt.add_confusion(results, ts_data.classes)
    rpt.save()
    if typst: rpt.compile()

if experiments['room_normalized']:
    name = 'room_normalized'
    dataset = 'room_250_16'
    batch_size = 200
    lr = 0.001
    epochs = 50

    stored_labels = np.load('dataset/labels.npz', allow_pickle=True)
    tr_labels = stored_labels['room_tr']
    ts_labels = stored_labels['room_ts']
    
    tr_data = IQDataset(tr_labels, decimation=2, normalized=True, window=400)
    ts_data = IQDataset(ts_labels, decimation=2, normalized=True, window=400)

    tr_loader = DataLoader(tr_data, batch_size, shuffle=True)
    ts_loader = DataLoader(ts_data, batch_size, shuffle=True)
    
    network = models.Multi_Net(input_len=400)
    opt = optim.Adam(network.parameters(), lr)

    Path(f"results/{name}").mkdir(exist_ok=True)

    loss = train(name, network, opt, tr_loader, epochs)
    results = test(network, ts_loader)
    
    rpt = report(name, dataset, lr, epochs)
    rpt.add_accuracy(results['accuracy'])
    rpt.add_loss_figure(loss)
    rpt.add_confusion(results, ts_data.classes)
    rpt.save()
    if typst: rpt.compile()

